"""
定义函数发生的事情   重要  类似于变量
1. 在内存中开辟空间
2. 将函数内部的代码放进去
3. 将这个内存空间的地址绑定给函数名
函数名的命名规范和变量名一样
定义函数的时候，函数内部的代码 不会执行，只会检测基本的语法错误
易错点：必须先定义函数，再使用函数  这里的顺序指的不是书写的顺序，而是执行的顺序
使用函数的本质
函数的内存地址()   ====>执行这个地址里面的代码   (执行了这个函数)
很重要的区分：
函数名            一个内存地址
函数名()         内存地址()   ===>执行了这个函数，并且得到这个函数的返回值
返回值：
    返回值：这个函数的结果
    举例： 张三，你将这个苹果去切好    功能  切水果
返回值  return   这是个关键字，只能出现在函数中
1. 函数一旦执行到了他，就会立即退出这个函数，后面的代码都不会执行了
2. return可以不写，如果不写，函数默认会给你return一个None
3. return 后面可以不写数据，如果不写就是默认None，也可以写一个或者多个，如果是多个
就用,号隔开，会形成一个元祖丢出去
参数
    形式参数:形参。写在定义函数后面的括号里面的
        类似于变量名  接受调用函数口号里面的具体的数据的
    实际参数:实参。写在调用函数后面的括号里面的
        类似于变量值  给定义函数的那个括号里面的那个参数去绑定一个具体的数据的
参数的基本原则：
    从左到右，一一对应
位置参数
    按照从左到右的顺序，将实参绑定给形参
关键字参数
    在调用函数的时候，按照key=value(变量名=变量值)的形式
    给形参绑定具体的数据，可以不按照从左到右的顺序来了
默认参数
    在定义函数的时候，可以给形参绑定一个具体的数据
    在调用这个函数的时候，你就可以不给这个形参绑定具体的数据了
    如果你不绑定，就按照定义函数的时候绑定的具体数据来，表示默认
    如果你传递了数据，就按照你的来
    例如：print(1) 不传递参数   以换位作为结尾
    例如：print(1,end='000') 传递参数   以000作为结尾
1. 顺序问题：
不管是在定义函数的时候，还是调用函数的时候
value,value,key=value
完整版的顺序，在讲完我们所有的参数之后，我们会再次总结
可变长度参数   (重要)
命名关键字参数(了解，了解即可，使用的少)

类似于print()一样，会发生一种情况，就是调用函数的时候，实参的个数不一定
那么在定义函数的时候，我们形参个数怎么办？
可变长度参数
在定义函数的括号内，给一个形参前面加一个*号，那么你在实际调用函数的时候，不管你传递
多少个位置参数，都OK了
将会将你所有的传递进来的实参，组成一个元祖
通常我们为了规范都会将这个形参叫做args
*args  只能用来接受任意个位置参数
key=value这种形式的接受不
在定义函数的时候，给一个形参前面加一个**号，那么你在实际调用函数的时候，不管你传递
多少个关键字参数，都OK了
将会将你所有的传递进来的实参，组成一个字典
通常我们为了规范都会将这个形参叫做kwargs
**kwargs  只能用来接受任意个关键字参数
注意：是在定义函数的时候
在定义函数的时候，*args,**kwargs  就表示可以接受任意多个的，任意形式的实参了
注意：扩展点  了解点
在调用函数的时候，将你的实参前面加一 *  ，就表示将这个实参里面的元素炸开
如果是字典，表示的是键  ，这个实参里面元素的个数要和定义函数的形参个数对应
在调用函数的时候，将你的实参前面加**，就表示将这个字典的实参，炸开关键字参数的形式
对于可变长度参数：
我们需要记住的是：
定义函数的时候，写一个*args,**kwargs  就表示可以接受任意多个，任意形式的实参了

了解的命名关键字参数(使用的少)  了解即可
在定义函数的括号里面，在你的* 之后定义的参数   命名关键字参数

所有的参数在一起的顺序
定义函数的时候：位置参数,默认参数,*args,命名关键字参数,**kwargs
调用函数的时候:位置参数,关键字参数
value,key=value

总结：
    形参类似于变量名，实参类似于变量值
    1. 参数必须是从左往右，一一对应的
    2. value,key=value
    3. 定义函数的时候,*args,**kwargs可以用来接受任意多个任意形式的实参

''"""
# def a(b,c,d=3333333):
#     # b = 1
#     # c = ?
#     print(b,c,d)
# # a(1,2,3)
# a(c=1,b=2,d=7777777)


# def print():
#     pass
#
# print()
# # 参数的个数不一致导致的报错 print()  同时打印多个数据？
# print(1,2,3,4,5,6,7)
# 本质：在调用函数的时候，实参的个数是不确定的
# def a(*args,**kwargs):  # 5
#     print(args)
#     print(kwargs)
#
# def b():
#     pass

# a(c=b)
# a(1)
# a(1,2)
# a(1,2,3)
# a(b=1,c=2,d=3) # key=value
# a(b=1,c=2) # key=value
# a(b=1) # key=value
# a(1,2,b=1,c=4) # key=value

def a(*args, **kwargs):  #
    print(args)
    print(kwargs)


a(1, 2, 3, name=34, ke=90)
#
#
# # a(1,2)
# s  = '12'
# s = [1,2]
# s = (1,2)
# s = {1,2}
# s = {'c':1,'b':2}
# print(*s)
# a=1,b=2
# a(*s)   # 在调用函数的实参前面加一颗星  相当于炸开了 打散了
# a(**s)   # 在调用函数的实参前面加一颗星  相当于炸开了 打散了
# def a(*args,x,y):
#     print(args)
#     print(x)
#     print(y)
#
# a(1,2,3,4,5,x=666,y=777)
# def a(*args,x,**kwargs): # 定义函数
#     # 我就希望得到一个参数  我需要明确的知道  至少要传递一个参数
#     print(args)
#     print(kwargs)
#
# a(x=1) # 调用函数
# 1. 在调用函数的时候，可能传递任意多个位置参数    value
# 2. 再调用函数的时候，可能传递任意多个关键字参数  key=value
# def a(a,b=3):  # value,
#     pass
#
# a(b=2,1)
'''
名称空间与作用域
思考一个问题：
已经有一份文件1.txt  再来一份文件，1.txt 会发生什么现像？
提前的文件就被覆盖了  重名就覆盖
如何解决重名就覆盖的问题呢？(不能换名字)
放在不同的空间,就可以解决重名覆盖的现像了
D:/1/1.txt
D:/2/1.txt  
名称空间：存放名称的空间,就是用来解决重名的问题
python中存在三种空间
1. 内建/内置名称空间
    当你启动了python解释器，就默认会为你产生一个空间
    用来存放Python解释器默认一启动就产生了的名字   input  print  
    当你的程序运行完了，Python解释器用完了，这个空间就销毁了
2. 全局名称空间
    当python执行你的Python程序，为你产生的空间
    用来存放你的程序中产生的名字(非函数内部)
3. 局部名称空间
    执行你的函数，你的函数内部的名字   局部名称空间
名称空间产生的顺序  内建>全局>局部
销毁顺序          局部>全局>内建

作用域
    1. 全局作用域
        内置名称空间
        全局名称空间
    2. 局部作用域
        局部名称空间
作用域
    在这个区域内，所有的名字大家都能用 
全局作用域
    内建的名字，你这个程序中产生的名字(除了函数内部的名字)
    在这个程序的任意位置都能使用这个名字
    除了函数内部的名字以外的名字，那么这个名字在程序的任意的地方都可以使用
局部作用域
    函数内部的名字，只有这个函数内部才能用，其他地方不能用 
总结：
    如果一个名字是在函数内部定义的，那么这个名字只能在这个函数内部使用，其他地方不能用
    如果一个名字不是在函数内部定义的，那么这个名字在任意地方都可以使用

一个名字的查找顺序问题：
    局部名称空间>全局名称空间>内建名称空间
见下面的案列
888  要学会自己去画图     

最后一个知识点
修改其他作用域的名字
     
在函数内部想要修改全局中的名字 需要先 写 global 你要修改的名字  然后再修改
tips: 注意  
本质上要注意，不是说所有对全局名字的修改都必须加glabal 
什么时候加glabal  如果你改动这个数据，会更改这个数据的内存地址的时候，才需要加

最后一个知识点  了解知识点  用的少
nonlocal 更改外层的函数的名字，会一层层的去找，如果最外层都找不到，就报错
global   在函数内部修改全局的名字 ，更改名字的内存地址

'''
# def a():
#     b = 1
#
# a()
# 1. python解释器 启动起来   软件
# 2. 执行你的程序
# 3. 调用你的函数

# def a():
#     b = 1
#     print(b)
# print(b)
# def c():
#     print(b)

# c()

# def a():
#     b = 1
#     print(b)
#
# print(b)  # 结果是:  直接报错 因为b这个名字在函数内部 ，只能在函数内部使用

# def a():
#     b = 1
#     print(b)
# b = 2
# print(b)  # 结果是什么？

# def a():
#     b = 1
#     print('函数中的',b)
# b = 2
# a()
# print('程序中的',b)   #  1   2

# def a():
#     # b = 1
#     print('函数中的',input)   #
# # b = 2
# a()
# print('程序中的',input)   #  局部没有  找全局  全局没有 找内置  内置还没有，就报错
# 查找顺序问题
# input
# input()
# 程序  细节是魔鬼
# def a():
#     # b = 1
#     print('函数中的',b)  #
#     b = 1
# b = 2
# a()
# print('程序中的',b) #
# 看图

# def a():
#     # global b  #  你可以改了
#     # b = 1
#     b.append(3)
#     print(b)
#
# b = [1,2]
# a()
# print('全局的',b)
x = 3


# def a():
#     x = 4
#
#     def b():
#         # global x
#         nonlocal x
#         x = 555
#         print('函数b的', x)
#
#     b()
#     print('函数a的', x)  #
#
#
# a()  #
# print('程序中的', x)

'''
题目
################################
# 1. 利用函数，实现对任意一份文件的复制
# 2. 利用函数和参数，实现对两个数字比较大小，返回更大的数字
# 3. 利用文件操作实现，将用户输入的账户和密码，以追加的方式保存成文件 db.txt
# 4. 利用文件操作，实现将用户输入的账户和密码，与db.txt文件里面的账户和密码进行
# 对比，如果账户和密码都对，则提示登录成功，如果用户输入的账户和密码和db.txt文件
# 的账户和密码都对比不上，则提示账户或密码错误

global    只能改全局
nonlocal  只能改局部外层函数

886  下课了   
'''
